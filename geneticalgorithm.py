# -*- coding: utf-8 -*-
"""GeneticAlgorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/samarasleal/Python-ComputationalHeuristics/blob/main/GeneticAlgorithm.ipynb

Prática de Metaheurísticas
Busca Populacional - Algoritmo Genético
"""

import random
import time
# Created by Samara Leal

# Classe dos Jogadores
class Jogadores:
  def __init__(self, nome, aptidao, num_partidas):
    self.name = nome
    self.aptidao = aptidao
    self.num_partidas = num_partidas
  def getName(self):
    return self.name
  def getAptidao(self):
    return self.aptidao
  def getNumPartidas(self):
    return self.num_partidas

# Solução Inicial com objetos da classe Jogador
jogador1 = Jogadores('Fábio', 7, 2)
jogador2 = Jogadores('Carlos', 9, 5)
jogador3 = Jogadores('Matheus', 6, 2)
jogador4 = Jogadores('Luan', 9, 6)
jogador5 = Jogadores('Podeisso', 4, 2)
jogador6 = Jogadores('Arnaldo', 3, 4)
jogador7 = Jogadores('Tulio', 4, 1)
jogador8 = Jogadores('Neymar', 7, 6)
jogador9 = Jogadores('Theus', 5, 1)
jogador10 = Jogadores('Fenômeno', 8, 7)
TIME = [jogador1, jogador2, jogador3, jogador4, jogador5, jogador6, jogador7, jogador8, jogador9, jogador10]

# Classe responsavel por escalar os jogadores selecionados em binario
class Binario:
  def __init__(self):
    self._dados = []
  def atribuir_jogadores(self, lista_jogadores, solucao):
    self._indice = 0    
    for valor in solucao:
      self._dados.append([lista_jogadores[self._indice], valor])
      self._indice += 1
  def alterar_valores(self, indice, valor):
    del self._dados[indice][1]
    self._dados[indice].append(valor)
  def get_dados(self):
    return self._dados
  # Apresenta o nome e se o jogador foi escalado ou não
  # Insere em jogadores_selecionados (global) os que foram escalados
  def situacao_jogadores(self, imprimir):
    jogadores_selecionados = []
    if (imprimir):
      print('\n--> Situacao dos Jogadores: \n')
    cont = 0
    a = self.get_dados()
    for i in a:
      if (imprimir):
        print('Jogador:', i[0].getName(), '  \t | ', ' Escalado: ', i[1], '\n')  
      if i[1] == 1:
        jogadores_selecionados.append(i[0])
      cont+=1
    return jogadores_selecionados

class Controller: 
  def checar_totalPartidas(self, jogadores, penalidade, imprimir):
    self._sum = 0
    self._aptidao = 0
    self._nome = " "
    for ind in jogadores:
      self._sum += ind.getNumPartidas()
      self._nome = self._nome + ind.getName()+", " 
      self._aptidao += ind.getAptidao()    
    if(penalidade):
      retorno = self.calcular_penalidade(self._sum, self._aptidao, self._nome, jogadores)
      self._aptidao = retorno[0]
    if (imprimir):
      self.imprimir_info(self._nome, self._sum, self._aptidao)
    return self._aptidao

  # Penalidade para número de partidas maior do que 20 ou time com número de jogadores escalados menor ou maior do que 5
  def calcular_penalidade(self, sum, aptidao, nome, jogadores):   
    if(sum>20) or (len(jogadores) != 5):     
      aptidao = aptidao - (aptidao * sum - 20)
      # print('\nLimite de Partidas Superior a 20 partidas ou número de jogadores escalados diferente de 5!')      
    return [aptidao, sum]

  def imprimir_info(self, nome, total, aptidao):
    print('\n--> Jogadores Selecionados: ', nome)
    print('--> Total Partidas: ', total)    
    print('--> Aptidao: ', aptidao)

"""Algoritmo Genético """

def populacao_inicial(tamanho): 
# População inicial (Gera soluções viáveis e inviáveis)
    k = 0
    p = []
    while (k<tamanho):
      s = []
      i = 0
      while (i<10):
        s.append(random.randint(0, 1))
        i+=1 
      p.append(s) 
      k+=1    
    return p

def selecao(pop):
  # Seleção por torneio ##########
  i = 0
  util = Controller()    
  # Primeira seleção
  # Indivíduo 1
  ind1 = random.randint(0, len(pop)-1)  
  # print("\nPrimeira seleção - Indivíduo 1: "+str(pop[ind1]))
  solucao1 = Binario()  
  solucao1.atribuir_jogadores(TIME, pop[ind1])
  jogadores_selecionados1 = solucao1.situacao_jogadores(False)
  aptidao1 = util.checar_totalPartidas(jogadores_selecionados1, True, False)
    
  # Indivíduo 2
  ind2 = random.randint(0, len(pop)-1)
  # Não pode ter seleção entre o indivíduo com ele mesmo
  # print("\nPrimeira seleção - Indivíduo 2: "+str(pop[ind2]))
  solucao2 = Binario()  
  solucao2.atribuir_jogadores(TIME, pop[ind2])
  jogadores_selecionados2 = solucao2.situacao_jogadores(False)
  aptidao2 = util.checar_totalPartidas(jogadores_selecionados2, True, False)

  # Segundo seleção
  # Indivíduo 1
  ind11 = random.randint(0, len(pop)-1)  
  # print("\nSegunda seleção - Indivíduo 1: "+str(pop[ind11]))
  solucao11 = Binario()  
  solucao11.atribuir_jogadores(TIME, pop[ind11])
  jogadores_selecionados11 = solucao11.situacao_jogadores(False)
  aptidao11 = util.checar_totalPartidas(jogadores_selecionados11, True, False)
    
  # Indivíduo 2
  ind22 = random.randint(0, len(pop)-1)
  # print("\nSegunda seleção - Indivíduo 2: "+str(pop[ind22]))
  solucao22 = Binario()  
  solucao22.atribuir_jogadores(TIME, pop[ind22])
  jogadores_selecionados22 = solucao22.situacao_jogadores(False)
  aptidao22 = util.checar_totalPartidas(jogadores_selecionados22, True, False)

  # Primeiro pai
  if (aptidao1 >= aptidao2):
    pai1 = pop[ind1]
    indicePai1 = ind1
    aptidaoPai1 = util.checar_totalPartidas(jogadores_selecionados1, True, False)
  else:
    pai1 = pop[ind2]
    indicePai1 = ind2
    aptidaoPai1 = util.checar_totalPartidas(jogadores_selecionados2, True, False)
  print("\nPai 1 selecionado: "+str(pai1))
  print("Pai 1 Aptidão: "+str(aptidaoPai1))

  # Segundo pai
  if (aptidao11 >= aptidao22):
    pai2 = pop[ind11]
    indicePai2 = ind11
    aptidaoPai2 = util.checar_totalPartidas(jogadores_selecionados11, True, False)
  else:
    pai2 = pop[ind22]
    indicePai2 = ind22
    aptidaoPai2 = util.checar_totalPartidas(jogadores_selecionados22, True, False)
  print("\nPai 2 selecionado: "+str(pai2))
  print("Pai 2 Aptidão: "+str(aptidaoPai2))
  return pai1, pai2, indicePai1, indicePai2, aptidaoPai1, aptidaoPai2

def recombinacao(pai1, pai2):
  pontoDeCorte = random.randint(1, len(pai1)-1)  
  i = 0
  filho1 = []
  filho2 = []
  while (i <len(pai1)):
    if (i < pontoDeCorte):       
      filho1.append(pai1[i])
      filho2.append(pai2[i])
    else:
      filho1.append(pai2[i])
      filho2.append(pai1[i])
    i+=1
  return filho1, filho2

def mutacao(filho):
  posicao = random.randint(1, len(filho)-1)  
  if (filho[posicao] == 0):
    filho[posicao] = 1
  else:
    filho[posicao] = 0
  return filho

"""Programa principal"""

# Principal
tamanhoPopulacao = 50 
taxaRecombinacao = 0.80
taxaMutacao = 0.30
numGeracoes = 50
pop = populacao_inicial(tamanhoPopulacao)
util = Controller() 
pi = 0
print("######### ---------- População Inicial ---------- #########")
while (pi < tamanhoPopulacao):
  solucao = Binario()  
  solucao.atribuir_jogadores(TIME, pop[pi])
  jogadores_selecionados = solucao.situacao_jogadores(False)   
  util.checar_totalPartidas(jogadores_selecionados, True, True)
  pi+=1
i = 1
while (i <= numGeracoes):
  print("\n######### ---------- Geração ---------- #########")
  j=0
  while (j < len(pop)):
    # Seleção
    print("\n ### PAIS ###")
    pai1, pai2, indPai1, indPai2, aptidaoPai1, aptidaoPai2 = selecao(pop)
      
    # Recombinação
    if (random.uniform(0,1) < taxaRecombinacao):
      filho1, filho2 = recombinacao(pai1, pai2)
      # Mutacao
      if (random.uniform(0,1) < taxaMutacao):
        filho1 = mutacao(filho1)
      if (random.uniform(0,1) < taxaMutacao):
        filho2 = mutacao(filho2) 
    
      print("\n ### FILHOS ###")
      # Avalia os melhores filhos para sobrevivem para a próxima geração (comparando com os pais)  
      # Aptidão filho 1
      solucao1 = Binario()  
      solucao1.atribuir_jogadores(TIME, filho1)
      jogadores_selecionados1 = solucao1.situacao_jogadores(False)
      aptidaoFilho1 = util.checar_totalPartidas(jogadores_selecionados1, True, True)
      
      # Aptidão filho 2
      solucao2 = Binario()  
      solucao2.atribuir_jogadores(TIME, filho2)
      jogadores_selecionados2 = solucao2.situacao_jogadores(False)
      aptidaoFilho2 = util.checar_totalPartidas(jogadores_selecionados2, True, True)
      
      # Troca a solução que tem o pior valor de aptidão do pai (pega o índice) pela solução que tem o melhor valor de aptidão do filho
      if (aptidaoPai1 <= aptidaoPai2):
        piorPai = indPai1
        piorPaiApt = aptidaoPai1
      else: 
        piorPai = indPai2
        piorPaiApt = aptidaoPai2
      if ((aptidaoFilho1 > piorPaiApt) or (aptidaoFilho2> piorPaiApt) ):
        if (aptidaoFilho1 >= aptidaoFilho2):
          melhorFilho = filho1
          melhorFilhoApt = aptidaoFilho1
        else: 
          melhorFilho = filho2
          melhorFilhoApt = aptidaoFilho2
        pop[piorPai] = melhorFilho
        print("\n Atualização na população - Melhor Filho: "+str(melhorFilhoApt))   
    j+=1
  i+=1
# print("População final")
# print(pop)

# Melhor solução - pop atualizada
t = 0
vetorAptidao = []
while (t < len(pop)):
  solucaoN = Binario()  
  solucaoN.atribuir_jogadores(TIME, pop[t])
  jogadores_selecionados = solucaoN.situacao_jogadores(False)   
  vetorAptidao.append(util.checar_totalPartidas(jogadores_selecionados, True, False))
  t+=1
maximoApt = max(vetorAptidao)
print("Maior aptidão igual a: "+str(maximoApt))

posicaoMaiorAptidao = vetorAptidao.index(maximoApt)
melhor = Binario()  
melhor.atribuir_jogadores(TIME, pop[posicaoMaiorAptidao])
jogadores_selecionados = melhor.situacao_jogadores(True)   
util.checar_totalPartidas(jogadores_selecionados, True, True)